from argparse import ArgumentParser
from pathlib import Path
from typing import Union, List, Tuple

def get_argument_parsed() -> ArgumentParser:
    parser = ArgumentParser(description="D-DroidHunter hunting malicious apps.")
    parser.add_argument(
        "--vtkey",
        dest="vt_apikey",
        required=True,
        help="Your VirusTotal API key"
    )
    parser.add_argument(
        "--mobsfkey",
        dest="mobsf_apikey",
        required=True,
        help="Your MobSF API key"
    )
    parser.add_argument(
        "--url",
        dest="mobsf_url",
        required=True,
        help="URL to MobSF instance"
    )
    parser.add_argument(
        "--samples-dir",
        dest="samples_dir",
        required=True,
        help="Path to the directory where the samples will be stored temporally"
    )
    parser.add_argument(
        "--json",
        dest="json_reports",
        required=True,
        help="Path to the output directory to store the JSON reports"
    )
    parser.add_argument(
        "--pdf",
        dest="pdf_reports",
        required=False,
        default=None,
        help="Path to the output directory to store the PDF report generated by MobSF"
    )
    parser.add_argument(
        "--db",
        dest="database_dir",
        required=True,
        help="Path to the database directory"
    )
    return parser


def check_file(file_path: str) -> bool:
    if Path(file_path).exists():
        return True
    return False

def resolve_path(filename: str):
    return Path(filename).resolve()

def delete_all_files(
    directory: Union[str, Path],
    recursive: bool = False,
    dry_run: bool = False,
    allow_root: bool = False
) -> Tuple[List[Path], List[Tuple[Path, Exception]]]:
    """
    Delete every regular file in `directory`.

    Args:
        directory: Directory path.
        recursive: If True, also delete files in subdirectories.
        dry_run: If True, do not delete; just return what *would* be deleted.
        allow_root: If True, allows operating on a filesystem root. Dangerous.

    Returns:
        (deleted, errors):
          - deleted: list of file paths successfully deleted (or would delete if dry_run)
          - errors: list of (path, exception) for any failures

    Raises:
        FileNotFoundError: If the directory does not exist.
        NotADirectoryError: If the path is not a directory.
        ValueError: If attempting to operate on filesystem root without allow_root.
    """
    p = Path(directory).resolve()

    if not p.exists():
        raise FileNotFoundError(f"{p} does not exists")
    if not p.is_dir():
        raise NotADirectoryError(f"{p} is not a directory")
    
    if not allow_root and p == Path(p.anchor):
        raise ValueError(f"Refusing to operate on filesystem root: {p}")
    
    candidates: List[Path] = list()
    interator = p.rglob("*") if recursive else p.iterdir()
    for path in interator:
        try:
            if path.is_file() or (path.is_symlink and not path.is_dir()):
                candidates.append(path)
        except PermissionError:
            continue
    
    deleted: List[Path] = list()
    errors: List[Tuple[Path, Exception]] = list()

    for f in candidates:
        if dry_run:
            deleted.append(f)
            continue
        try:
            f.unlink()
            deleted.append(f)
        except Exception as e:
            errors.append((f, e))

    return deleted, errors